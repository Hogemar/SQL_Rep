USE MASTER

GO

CREATE DATABASE Стоматология

ON

(NAME='Стоматология_Data',
FILENAME='C:\Users\User\Desktop\labs\Проектирование моделей данных\Стоматология\Стоматология_Data.mdf',
SIZE=3,
MAXSIZE=10,
FILEGROWTH=1)

LOG ON

(NAME='Стоматология_log', 
FILENAME='C:\Users\User\Desktop\labs\Проектирование моделей данных\Стоматология\Стоматология_Data.ldf',
SIZE=3,
MAXSIZE=10,
FILEGROWTH=1)

USE Стоматология
Go

CREATE TABLE Услуги
(Код smallint NOT NULL PRIMARY KEY,
Название varchar(50) NOT NULL)

CREATE TABLE Пациенты
(Номер smallint NOT NULL PRIMARY KEY,
Фамилия varchar (40) NOT NULL,
Адрес varchar (80),
[Год рождения] smallint NOT NULL )

CREATE TABLE ОказанныеУслуги
(Пациент smallint NOT NULL,
Услуга smallint NOT NULL,
Время time NOT NULL,
Стоимость smallmoney NOT NULL,
FOREIGN KEY (Пациент)REFERENCES Пациенты(Номер)/*ON DELETE CASCADE*/,
FOREIGN KEY (Услуга) REFERENCES Услуги(Код)
)/*ON DELETE CASCADE)*/

ALTER TABLE Услуги
ADD CONSTRAINT Unique_Название UNIQUE (Название)

ALTER TABLE ОказанныеУслуги
ADD CONSTRAINT PK_Время PRIMARY KEY (Время, Пациент)

ALTER TABLE Пациенты
ADD CHECK ([Год рождения]>=1920)

INSERT INTO Услуги
VALUES 
(100, 'Удаление зубов'),
(101, 'Лечение зубов'),
(102, 'Протезирование'),
(103, 'Отбеливание'),
(104, 'Чистка полости рта'),
(105, 'Декоративное украшение зубов'),
(106, 'Рентгенодиагностика'),
(107, 'Пародонтология'),
(108, 'Исправление прикуса'),
(109, 'Реставрация зубов')

INSERT INTO Пациенты
VALUES 
(1, 'Петров', 'Солнечная, 8, 46', 1989),
(2, 'Иванов', 'Радищева, 22, 22', 1961),
(3, 'Потапова', 'Горького, 37, 12', 1968),
(4, 'Зотов', 'Павлова, 1, 10', 1984),
(5, 'Ковалева', 'Свободы, 81, 70', 1989),
(7, 'Фролов', 'Почтовая, 65, 6', 1961),
(8, 'Татаринова', 'Соборная, 2, 10', 1975),
(9, 'Ильин', 'Урицкого, 67, 3', 1987),
(10, 'Сафронова', 'Каляева, 13, 20', 1980)

INSERT INTO Пациенты(Номер, Фамилия, [Год рождения])
VALUES  (6, 'Сидоров',  1989)

INSERT INTO ОказанныеУслуги
VALUES
(1, 102, '12:00:00', 600),
(8, 104, '15:00:00', 500),
(8, 109, '10:00:00', 100),
(10, 107, '08:00:00', 250),
(6, 104, '17:00:00', 1000),
(2, 105, '21:00:00', 750),
(4, 103, '19:00:00', 400),
(7, 102, '12:00:00', 5000),
(3, 109, '11:30:00', 260),
(4, 106, '10:40:00', 340),
(1, 102, '17:10:00', 560),
(9, 104, '15:00:00', 50),
(10, 107, '08:45:00', 100),
(7, 100, '09:00:00', 2500),
(3, 100, '10:30:00', 400),
(2, 103, '11:00:00', 980),
(1, 100, '16:00:00', 120),
(4, 101, '12:40:00', 300),
(9, 100, '14:35:00', 460),
(6, 105, '20:00:00', 900)

CREATE TYPE Группа_крови
FROM varchar(5)

/*ALTER TABLE Пациенты
ADD [Группа крови] Группа_крови DEFAULT 'O' CHECK ([Группа крови] IN ('O', 'A', 'B', 'AB'))*/
 
GO
-- Создание DEFAULT значения
CREATE DEFAULT dbo.DefaultГруппа_крови AS 'O';

GO

ALTER TABLE Пациенты
ADD Группа_крови varchar(5) DEFAULT dbo.DefaultГруппа_крови WITH VALUES;

ALTER TABLE Пациенты
ADD CONSTRAINT CK_Группа_крови CHECK (Группа_крови IN ('O', 'A', 'B', 'AB'));







--- 14.02.2024 Лаба ---

		/* 1. Изучение оператора CREATE RULE для создания правил, 
		использование системной хранимой процедуры sp_bindrule для 
		связывания правила с объектами БД.*/

/* 1.1. Создать правило, которое позволяет использовать в качестве 
значений атрибута только те значения, которые начинаются с 
русской буквы.*/

GO
CREATE RULE R_startswrus
	AS @str LIKE '[А-Я]%'
GO

/*1.2. Связать правило со столбцом Фамилия пациента и со столбцом 
Название услуги.*/
EXEC sp_bindrule 'R_startswrus', 'Пациенты.Фамилия'
EXEC sp_bindrule 'R_startswrus', 'Услуги.Название'

		/*2. Изучение оператора CREATE DEFAULT для создания умолчаний, 
		использование системной хранимой процедуры sp_binddefault для 
		связывания умолчания с объектами БД.*/

/*2.1. Создать умолчание 200.*/
GO
CREATE DEFAULT D_200
	AS 200
GO

/*2.2. Связать умолчание со столбцом Стоимость приёма.*/
EXEC sp_bindefault 'D_200', 'ОказанныеУслуги.Стоимость'

		/*3. Изучение оператора CREATE VIEW для создания представлений, 
		выполнение запросов к представлениям.*/

/*3.1. Создать представление с информацией о приёмах. 
Представление должно включать столбцы Фамилия пациента, 
Название услуги, Время, Стоимость (в руб.).*/
GO
CREATE VIEW V_Приёмы AS
	SELECT Фамилия, Название, Время, STR(Стоимость) + 'руб.' AS Стоимость
	  FROM (Услуги JOIN ОказанныеУслуги ON Услуги.Код = ОказанныеУслуги.Услуга) JOIN Пациенты ON ОказанныеУслуги.Пациент = Пациенты.Номер

/*3.2. Выполнить запрос, который на основе созданного в п.3.1 
представления для каждого пациента выводит фамилию 
пациента и суммарное количество оказанных ему услуг.*/
GO
SELECT Фамилия, COUNT(Название) AS [Количество приёмов]
	FROM V_Приёмы
	GROUP BY Фамилия


/*4. Создание представлений с ограничением WITH CHECK OPTION. 
Модификация базовых таблиц через представление.*/

/*4.1Создать представление с информацией о пациентах, которые 
родились до 1995 года.
*/
GO
CREATE VIEW V_Пациенты_до95 AS
 SELECT*
 FROM Пациенты
 WHERE [Год рождения]<1995
 WITH CHECK OPTION

 /*4.2. Разработать запросы для добавления, удаления и обновления
одной записи о пациенте на основе созданного в п. 4.1 
представления.
*/
GO
UPDATE Пациенты
SET Пациенты.Фамилия = 'Ильич'
FROM V_Пациенты_до95
WHERE Пациенты.Фамилия = 'Ильин'

GO
DELETE Пациенты
FROM V_Пациенты_до95
WHERE Пациенты.Фамилия='Фролов'

GO
INSERT INTO V_Пациенты_до95
VALUES (12,'Тихонов', 'Солнечная, 15, 34', 1996)


--- ЗАДАЧИ на сдачу от 28.02.24 ---

-- Создать представление, кот. выводит услуги, на которые не было посещений
GO
CREATE VIEW useless_услуги AS
	SELECT Код, Название
	FROM Услуги
	WHERE Код NOT IN (SELECT Услуга FROM ОказанныеУслуги)

GO

-- Создать правило, что пациент старше 18 лет
GO
CREATE RULE R_older18
	AS YEAR(GETDATE()) - @birthYear >=18
GO

EXEC sp_bindrule 'R_older18', 'Пациенты.[Год рождения]'


--* Лаба по хранимым процедурам 28.02.24 *--

/*1.1. Разработать хранимую процедуру, которая по заданному 
номеру пациента возвращает его фамилию и адрес.*/

GO
CREATE PROCEDURE GetPacient @pacientNum smallint AS
	SELECT Фамилия, Адрес
	FROM Пациенты
	WHERE Номер = @pacientNum

EXEC GetPacient 2

/*1.3. Разработать хранимую процедуру, которая по заданным 
значениям номера пациента, названия услуги и времени 
приема выводит значение стоимости в валюте, заданной 
пользователем.*/
DROP PROCEDURE PrintPrice
GO
CREATE PROCEDURE PrintPrice
	@pacientNum smallint,
	--@serviceName varchar(50),
	@serviceTime time(7),
	@currency varchar(15) = 'доллар'		
	AS

	IF(@currency NOT IN('рубль', 'евро', 'доллар'))
		BEGIN
			PRINT 'Неизвестная валюта!'
			Return -4
		END

	DECLARE @pacientName varchar(40)
	SELECT @pacientName = Фамилия FROM Пациенты WHERE Номер = @pacientNum
	
	IF(@pacientName IS NULL)
		BEGIN
			PRINT 'Неверный номер пациента!'
			Return -1
		END

	DECLARE @servicePrice smallmoney--varchar(20)
	SELECT @servicePrice = Стоимость FROM ОказанныеУслуги WHERE Пациент = @pacientNum AND Время = @serviceTime
	
	IF(@servicePrice IS NULL)
		BEGIN
			PRINT 'Не найдена запись на приём!'
			Return -3
		END

	DECLARE @serviceName varchar(50)
	SELECT @serviceName = Название FROM Услуги WHERE Код = (SELECT Услуга FROM ОказанныеУслуги WHERE Пациент = @pacientNum AND Время = @serviceTime)

	PRINT 'Время приёма: ' + CONVERT(varchar(10), @serviceTime)
	PRINT 'Пациент: ' + @pacientName + ', Услуга: ' + @serviceName

	IF(@currency = 'евро')
		PRINT 'Стоимость: ' + CONVERT(varchar(20), @servicePrice/100.0) + ' евро'
	ELSE IF(@currency = 'доллар')
		PRINT 'Стоимость: ' + CONVERT(varchar(20), @servicePrice/70.0) + ' долларов'
	ELSE
		PRINT 'Стоимость: ' + CONVERT(varchar(20), @servicePrice) + ' рублей'

GO
EXEC PrintPrice 3, '11:30:00'

--1.2. Разработать хранимую процедуру, которая осуществляет 
--вставку записей в таблицу Пациенты. Хранимая процедура 
--должна обеспечить защиту данных от дублирования согласно 
--следующему правилу: поликлинику могут посещать пациенты 
--с одинаковыми фамилиями, но у них должны быть разные 
--значения адреса.
GO
CREATE PROCEDURE AddPacient 
	@num smallint,
	@LastName varchar (40),
	@Adress varchar (80),
	@BitrhDay smallint
	as
	if not exists (Select 1 From Пациенты Where Фамилия =@LastName and  Адрес =@Adress)
		begin
			Insert into Пациенты (Номер,Фамилия,Адрес, [Год рождения])
			Values (@num,@LastName,@Adress, @BitrhDay)
			print 'Запись успешно добавлено'
		end
	else print 'Ошибка при добавлении'
go

exec AddPacient 11,'Петров','Солнечная, 9, 46',1990
go

--1.4 Разработать хранимую процедуру, которая изменяет стоимость 
--всех приёмов у стоматолога для заданной пользователем 
--услуги согласно скидкам, указанным в  таблице
DROP PROCEDURE ChangeCoast
GO

Create procedure ChangeCoast
	@num smallint
as 
	DECLARE @count smallint
	SET @count = 0

	Select @count = count(ОказанныеУслуги.Пациент) 
		From ОказанныеУслуги Join Пациенты on ОказанныеУслуги.Пациент = Пациенты.Номер
		Where ОказанныеУслуги.Пациент= @num

	UPDATE ОказанныеУслуги
	SET Стоимость = CASE
		WHEN @count = 1				 THEN Стоимость - Стоимость *0.2
		WHEN @count between 2 and 10 THEN Стоимость - Стоимость*0.3
		WHEN @count >10				 THEN Стоимость - Стоимость*0.7
		ELSE Стоимость
		END
	WHERE ОказанныеУслуги.Пациент = @num


	--if (@count =1)
	--	begin
	--		Update ОказанныеУслуги
	--		Set Стоимость =Стоимость - Стоимость*0.2
	--		Where ОказанныеУслуги.Пациент=@num 
	--	end

	--if(@count between 2 and 10)
	--	begin
	--		Update ОказанныеУслуги
	--		Set Стоимость = Стоимость - Стоимость*0.3
	--		Where ОказанныеУслуги.Пациент=@num
	--	end

	--if (@count >10)
	--	begin
	--		Update ОказанныеУслуги
	--		Set Стоимость = Стоимость - Стоимость*0.7
	--		Where ОказанныеУслуги.Пациент=@num
	--	end
go 

exec ChangeCoast 1
go

--* СДАЧА лабы по хранимым процедурам 27.03.24 *--
DROP PROCEDURE CHECK_IF_LESS_3_USLUGI
GO
-- 1)	Процедуру, кот. проверяет, что у клиента запись в указанный день меньше 3 услуг
CREATE PROCEDURE CHECK_IF_LESS_3_USLUGI
	@pacientNum smallint
	AS

	IF(SELECT COUNT(Услуга)
		FROM ОказанныеУслуги
		WHERE Пациент = @pacientNum) < 3
	--RETURN 1
	PRINT 'Всё круто, услуг меньше 3'

	ELSE
	--RETURN 0
	PRINT 'Всё плохо, услуг уже 3+'

GO
EXEC CHECK_IF_LESS_3_USLUGI 1

-- 2)	Процедуру, кот. выводит статистику услуга-прибыль
GO
CREATE PROCEDURE STATISTIC_USLUGA_PROFIT
AS
	SELECT Название as 'услуга', SUM(Стоимость) as 'прибыль'
		FROM ОказанныеУслуги JOIN Услуги on Услуга = Код
		GROUP BY Название

GO
EXEC STATISTIC_USLUGA_PROFIT

--- 06,04,24 практика ---

--после поступоения абитуриентов распределяют по группам.
--группа не обязательно содержит студентов,
-- группе назначается куратор
--студент поступает по основе обучения
--в группе обязательно назначаются староста, зам старасты и профорг из студентов этой же группы

--Сущности: группа, студент, куратор, (староста, зам старосты, профорг)?, основа обучения

--Связи:
--Студент обучается в Группе на Основе обучения
--У Группы есть Куратор
--Студент явл. Старостой
--Студент явл. Зав старостой
-- Студент явл Профоргом


--- ЛР РАЗРАБОТКА ФУНКЦИЙ ---

--1.1  Разработать функцию, возвращающую список пациентов, 
--которые не воспользовались ни одной услугой в настоящее 
--время.
GO
CREATE FUNCTION Неиспользовавшие_услуги()
RETURNS TABLE
AS
RETURN
(
    SELECT P.Номер, P.Фамилия
    FROM Пациенты P
    LEFT JOIN ОказанныеУслуги S ON P.Номер = S.Пациент
    WHERE S.Пациент IS NULL
);
GO
SELECT * FROM Неиспользовавшие_услуги();

--1.2. Разработать функцию, возвращающую список пациентов, 
--которые не отбеливали зубы

GO

CREATE FUNCTION Не_отбеливали_зубы()
RETURNS TABLE
AS
RETURN
(
	SELECT DISTINCT P.Номер, P.Фамилия
	FROM Пациенты P
	WHERE Номер NOT IN ( SELECT DISTINCT Пациент
							FROM ОказанныеУслуги JOIN Услуги ON Услуга = Код
							WHERE Услуги.Название = 'Отбеливание'	)
	
);
GO
drop FUNCTION Не_отбеливали_зубы;

SELECT * FROM Не_отбеливали_зубы();
GO

--1.3.Разработать функцию, возвращающую список пациентов, 
--которые воспользовались всеми видами услуг поликлиники
CREATE FUNCTION Пациенты_с_всеми_видами_услуг()
RETURNS TABLE
AS
RETURN
(
    SELECT П.Номер, П.Фамилия
    FROM Пациенты П
    LEFT JOIN (
        SELECT Пациент, COUNT(DISTINCT Услуга) AS КоличествоУслуг
        FROM ОказанныеУслуги
        GROUP BY Пациент
    ) AS УслугиПоПациентам ON П.Номер = УслугиПоПациентам.Пациент
    CROSS JOIN (
        SELECT COUNT(*) AS ОбщееКоличествоУслуг
        FROM Услуги
    ) AS ОбщееКоличествоУслуг
    WHERE УслугиПоПациентам.КоличествоУслуг = ОбщееКоличествоУслуг.ОбщееКоличествоУслуг
);
GO

drop FUNCTION Пациенты_с_всеми_видами_услуг;

SELECT * FROM Пациенты_с_всеми_видами_услуг();

--1.4. Разработать функцию, которая возвращает список приёмов, на 
--которых оказывалась заданная услуга
GO
CREATE FUNCTION Приёмы_по_услуге(@ID_услуги INT)
RETURNS TABLE
AS
RETURN
(
    SELECT DISTINCT  Время, Пациент
    FROM ОказанныеУслуги
    WHERE ОказанныеУслуги.Услуга = @ID_услуги
);
GO
SELECT * FROM Приёмы_по_услуге(100);

--1.5. Разработать функцию, которая вычисляет суммарное 
--количество приёмов у стоматолога для каждой услуги и 
--отклонение его от среднего суммарного количества приёмов
GO
CREATE FUNCTION Суммарное_количество_услуг_и_отклонение()
RETURNS TABLE
AS
RETURN
(
    SELECT Услуга,
        
        COUNT(*) AS Суммарное_количество_услуг,
        COUNT(*) - AVG(COUNT(*)) OVER() AS Отклонение
    FROM 
        ОказанныеУслуги
		GROUP BY Услуга
   
);
GO
drop FUNCTION Суммарное_количество_услуг_и_отклонение;

SELECT * FROM Суммарное_количество_услуг_и_отклонение();


--- ЛР РАЗРАБОТКА ТРИГГЕРОВ ---

--- 1. Изучение оператора CREATE TRIGGER для создания триггеров к базовым таблицам БД.

--1.1. Разработать AFTER-триггер, который позволяет удалять 
-- информацию обо всех предоставляемых услугах из таблицы 
-- Услуги, кроме услуги с кодом 1. Считать, что пользователю 
-- предоставляется возможность удаления множества записей в таблице

CREATE TRIGGER After_DeleteService
ON Услуги
AFTER Delete
AS
    IF EXISTS (SELECT 1 FROM deleted WHERE Код = 1)
	BEGIN
		INSERT INTO Услуги
			SELECT * FROM deleted
			WHERE Код = 1
	END
GO



--1.2. Разработать INSTEAD OF-триггер для рассматриваемого в 
--п.1.1 задания.

CREATE TRIGGER DeleteServiceInsteadOf
ON Услуги
INSTEAD OF DELETE
AS
    -- Удаляем разрешенные записи из основной таблицы
    DELETE FROM Услуги WHERE Код IN 
		(SELECT Код FROM deleted WHERE Код !=1)
GO



--1.3 Разработать триггер, который позволяет изменять значение
-- стоимости приёма только на большее значение. Считать, что 
-- пользователю предоставляется возможность модификации 
-- множества записей в таблице.
CREATE TRIGGER UpdateServiceCost
ON ОказанныеУслуги
INSTEAD OF UPDATE
AS
BEGIN
    IF UPDATE(Стоимость)
    BEGIN
	
	DECLARE @Пациент smallint,
			@Время time,
			@НоваяСтоимость smallmoney

	DECLARE cur CURSOR FOR
	SELECT Пациент, Время, Стоимость
	FROM inserted

	OPEN cur

	WHILE @@FETCH_STATUS = 0
		BEGIN
		FETCH NEXT FROM cur INTO @Пациент, @Время, @НоваяСтоимость

		UPDATE ОказанныеУслуги
		SET Стоимость = CASE WHEN @НоваяСтоимость > Стоимость
							 THEN @НоваяСтоимость
							 ELSE Стоимость END
		WHERE Пациент = @Пациент AND Время = @Время
		END

	CLOSE cur
	DEALLOCATE cur

    END
END
GO

--2. Создание триггеров и представлений

-- 2.1. Создать представление с информацией об оказанных услугах. 
-- Представление должно включать столбцы: Номер пациента, Фамилия пациента, Код услуги, Название услуги, Время, Стоимость (в руб.)
CREATE VIEW Информация_об_оказанных_услугах
AS
SELECT 
    П.Номер AS 'Номер пациента',
    П.Фамилия AS 'Фамилия пациента',
    ОУ.Услуга AS 'Код услуги',
    У.Название AS 'Название услуги',
    ОУ.Время,
    ОУ.Стоимость AS 'Стоимость, руб.'
FROM 
    ОказанныеУслуги ОУ
	INNER JOIN 
    Пациенты П ON ОУ.Пациент = П.Номер
	INNER JOIN 
    Услуги У ON ОУ.Услуга = У.Код
GO

-- 2.2. Разработать триггер, который позволяет вносить информацию 
-- о приёмах через представление. Считать, что пользователю 
-- предоставляется возможность вставки только одной записи 
-- через представление. Предусмотреть вывод сообщения об 
-- ошибке в случае ввода информации о несуществующих услуге
-- или пациенте.
CREATE TRIGGER InsertAppointmentInfo ON Информация_об_оказанных_услугах
INSTEAD OF INSERT
AS
BEGIN
    -- Проверка на существование указанной услуги и пациента
    IF (SELECT [Номер пациента] FROM inserted) IN (SELECT Номер FROM Пациенты)
	AND(SELECT [Код услуги] FROM inserted) IN (SELECT Код FROM Услуги)

	    BEGIN
        -- Вставка информации об оказанных услугах
        INSERT INTO ОказанныеУслуги (Пациент, Услуга, Время, Стоимость)
        SELECT 
            i.[Номер пациента],
            i.[Код услуги],
            i.Время,
            i.[Стоимость, руб.]
        FROM 
            inserted i;
		END

	ELSE

		BEGIN
		-- Если указаны несуществующие пациент или услуга, выводим сообщение об ошибке
		PRINT 'Ошибка: Введена информация о несуществующем пациенте или услуге.'
		ROLLBACK TRAN
		END
END;